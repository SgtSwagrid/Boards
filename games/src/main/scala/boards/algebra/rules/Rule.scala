package boards.algebra.rules

import boards.algebra.rules.Combinator.*
import boards.algebra.state.Piece.PieceType
import boards.algebra.state.GameState
import boards.imports.games.{*, given}
import boards.imports.math.{*, given}
import boards.algebra.rules.Effect.{MapEffect, TerminalEffect}
import Rule.Query

/**
 * A compositional procedure for generating legal successor states given some current state.
 */
trait Rule:
  
  /**
   * @param state the current game state.
   * @param query a filter on the types of action to consider.
   * @return An iterator over all possible successor states.
   */
  def next(state: GameState, query: Query): Iterator[GameState]
  
  /**
   * @param state the current game state.
   * @param query a filter on the types of action to consider.
   * @return An iterator over all possible legal actions.
   */
  def actions(state: GameState, query: Query) =
    next(state, query).flatMap(_.actionOption)
  
  /**
   * A <b>sequencing</b> operator for requiring the user to perform multiple actions in order.
   *
   * This operator is associative but non-commutative.
   */
  def |> (that: => Rule): Rule =
    SequenceRule(this, that)
  
  /**
   * A <b>sequencing</b> operator for requiring the user to perform multiple actions in reverse order.
   *
   * This operator is associative but non-commutative.
   */
  final def <| (that: => Rule): Rule = that |> this
  
  final def thenIf(condition: GameState ?=> Boolean)(that: => Rule): Rule =
    this |> that.maybe(condition)
  
  /**
   * A <b>union</b> operator for allowing the player to choose one of multiple possible actions.
   *
   * This operator is associative, and commutative provided that
   * the same action isn't generated by both operands.
   */
  def | (that: => Rule): Rule =
    UnionRule(this, that)
  
  /**
   * An operator for requiring the user to perform multiple actions in any order.
   *
   * This operator is non-associative, but commutative provided that
   * the same action isn't generated by both operands.
   */
  def & (that: => Rule): Rule =
    (this |> that) | (that |> this)
    
  def ?: (that: Rule): Rule =
    Rule.switch(if that.canAct then that else this)
    
  def orElseIfImpossible(that: => Rule): Rule = this ?: that
  
  final def from(state: GameState): Capability = Capability(this, state)
  
  final def require(condition: GameState ?=> Boolean): Rule =
    FilterRule(this, implicit ctx => condition)
    
  final def requireInCase(condition: GameState ?=> PartialFunction[GameState, Boolean]): Rule =
    require(condition.lift(summon[GameState]).getOrElse(true))
  
  final def requireOnlyCase(condition: GameState ?=> PartialFunction[GameState, Boolean]): Rule =
    require(condition.lift(summon[GameState]).getOrElse(false))
  
  /**
   * Allow the player to decide whether they want to execute this rule.
   *
   * In cases where there is no ambiguity, the player will be able to skip this rule implicitly,
   * just by performing the subsequent action.
   * Otherwise, the player will be asked to skip explicitly by clicking a button.
   */
  final def optional: Rule = this | Rule.skip
  
  final def thenSwitch(brancher: GameState ?=> Rule): Rule =
    this |> Rule.switch(brancher)
  
  /**
   * Conditionally execute this rule.
   * When the condition is not met, defaults to 'Rule.none'.
   *
   * Recommended for use when the current rule is part of a group of rules composed by '|'.
   *
   * See also: 'Rule.maybe'.
   */
  final def when(condition: GameState ?=> Boolean): Rule =
    Rule.switch(if condition then this else Rule.none)
  
  /**
   * Conditionally execute this rule.
   * When the condition is not met, defaults to 'Rule.skip'.
   *
   * Recommended for use when the current rule is part of a chain of rules composed by '|>'.
   *
   * See also: 'Rule.when'.
   */
  final def maybe(condition: GameState ?=> Boolean): Rule =
    Rule.switch(if condition then this else Rule.skip)
    
  final def repeat(n: Int): Rule =
    if n <= 0 then Rule.skip
    else if n == 1 then this
    else this |> this.repeat(n - 1)
    
  final def repeat(min: Int, max: Int): Rule =
    this.repeat(min) |> this.optional.repeat(max - min)
    
  final def repeatWhile(condition: GameState ?=> Boolean): Rule =
    Rule.switch(if condition then this |> this.repeatWhile(condition) else Rule.skip)
    
  final def repeatUntil(condition: GameState ?=> Boolean): Rule =
    this.repeatWhile(!condition)
    
  final def repeatTo(condition: GameState ?=> Boolean): Rule =
    this.repeatUntil(condition) |> this
    
  final def repeatDoWhile(condition: GameState ?=> Boolean): Rule =
    this |> this.repeatWhile(condition)
    
  final def repeatForever: Rule =
    this |> this.repeatForever
  
object Rule:
  
  /**
   * An empty rule that disallows all actions.
   *
   * Acts as the identity under the '|' operator.
   *
   * When composed with any other rules by '|>', the whole composite becomes impossible to complete.
   *
   * See also: 'Rule.skip'.
   */
  val none: Rule = EmptyRule
  
  /**
   * An empty rule that requires doing nothing and thus skipping to the next rule.
   *
   * Acts as the identity under the '|>' operator.
   *
   * When composed with any other rules by '|', the whole composite becomes optional.
   *
   * See also: 'Rule.none'.
   */
  val skip: Rule = SkipRule
  
  def union(rules: => Rule*): Rule = rules.foldLeft(Rule.none)(_ | _)
  def union(rules: Iterable[Rule]): Rule = rules.foldLeft(Rule.none)(_ | _)
  def sequence(rules: => Rule*): Rule = rules.foldLeft(Rule.skip)(_ |> _)
  def sequence(rules: Iterable[Rule]): Rule = rules.foldLeft(Rule.skip)(_ |> _)
  def first(rules: => Rule*): Rule = rules.foldLeft(Rule.none)(_ ?: _)
  def first(rules: Iterable[Rule]): Rule = rules.foldLeft(Rule.none)(_ ?: _)
  
  def optional(rule: GameState ?=> Rule): Rule =
    Rule.switch(rule).optional
  
  def switch(brancher: GameState ?=> Rule): Rule =
    SwitchRule(implicit ctx => brancher)
    
  /**
   * Conditionally execute the following rule.
   * When the condition is not met, defaults to 'Rule.none'.
   *
   * Recommended for use when the current rule is part of a group of rules composed by '|'.
   *
   * See also: 'Rule.maybe'.
   */
  def when(condition: GameState ?=> Boolean)(rule: GameState ?=> Rule): Rule =
    Rule.switch(if condition then rule else Rule.none)
    
  def whenCase(rule: GameState ?=> PartialFunction[GameState, Rule]): Rule =
    Rule.switch(rule.lift(summon[GameState]).getOrElse(Rule.none))
  
  /**
   * Conditionally execute the following rule.
   * When the condition is not met, defaults to 'Rule.skip'.
   *
   * Recommended for use when the current rule is part of a chain of rules composed by '|>'.
   *
   * See also: 'Rule.when'.
   */
  def maybe(condition: GameState ?=> Boolean)(rule: GameState ?=> Rule): Rule =
    Rule.switch(if condition then rule else Rule.skip)
    
  def maybeCase(rule: GameState ?=> PartialFunction[GameState, Rule]): Rule =
    Rule.switch(rule.lift(summon[GameState]).getOrElse(Rule.skip))
    
  def repeat(n: Int)(rule: GameState ?=> Rule): Rule =
    Rule.switch(rule).repeat(n)
    
  def repeat(min: Int, max: Int)(rule: GameState ?=> Rule): Rule =
    Rule.switch(rule).repeat(min, max)
    
  def repeatWhile(condition: GameState ?=> Boolean)(rule: GameState ?=> Rule): Rule =
    Rule.switch(rule).repeatWhile(condition)
  
  def repeatUntil(condition: GameState ?=> Boolean)(rule: GameState ?=> Rule): Rule =
    Rule.switch(rule).repeatUntil(condition)
  
  def repeatTo(condition: GameState ?=> Boolean)(rule: GameState ?=> Rule): Rule =
    Rule.switch(rule).repeatTo(condition)
  
  def repeatDoWhile(condition: GameState ?=> Boolean)(rule: GameState ?=> Rule): Rule =
    Rule.switch(rule).repeatDoWhile(condition)
    
  def repeatForever(rule: GameState ?=> Rule): Rule =
    Rule.switch(rule).repeatForever
  
  def alternatingTurns(rule: GameState ?=> Rule): Rule =
    (Rule.switch(rule) |> Effect.endTurn).repeatForever
  
  /**
   * Generates no actions.
   * Acts as the identity under the '|' operator.
   */
  private[algebra] case object EmptyRule extends Rule:
    def next(state: GameState, query: Query): Iterator[GameState] = Iterator.empty
    override def | (that: => Rule): Rule = that
    override def |> (that: => Rule): Rule = this
  
  /**
   * Generates a single skip action.
   * Acts as the identity under the '|>' operator.
   */
  private[algebra] case object SkipRule extends Rule:
    def next(state: GameState, query: Query): Iterator[GameState] = state match
      case _: FinalState => Iterator.empty
      case state: NonFinalState =>
        Iterator.single(InterimState(state.now, Action.skip, state, Rule.skip))
    override def |> (that: => Rule): Rule = that
  
  type Query = PartialFunction[Generator, Generator]
  
  given (using state: GameState): Conversion[Rule, Capability] = _.from(state)